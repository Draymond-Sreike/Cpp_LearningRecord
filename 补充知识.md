# 补充知识

我们在第1点的最后提到的要**补充的小知识**，从这里开始：

（前情说明：这里我本来预料的结果应该是：当我删去函数的返回值类型`MyInteger&`中的`&`时，编译器不会报任何错误。但是没想到编译器居然报错了，开始的想法是编译既然报错了，不是自己预料中的事情，怕等下展开讲的时候讲不清楚......于是想着这部分的知识拓展要不然就不做了，以免让自己这篇已经写得自我感觉有点成就感的小博客[《左移运算符重载》](D:\C++Learning\Note\4.4 友元.md)就因为这里的这部分的内容解释不清楚而有些尴尬，从而导致整篇博客就因为这里的一点小插曲而留下一些小污点之类的......但是本着立足事实，深究本质的初衷，我决定还是就事论事，将实际产生的问题展示出来，然后看看能不能查明原因予以解决（就算查不明也能让大家一起来思考这个问题嘛，也说不定自己就真的查明了捏？嘿嘿......做以下这部分内容的展示之前，我的确是这么安慰自己的......所以下面的部分与其说是知识的补充，倒不如说是我对问题产生和尝试解决的记录，我会如实记录我的思考过程。如果大家对这部分内容不感兴趣可以直接跳回原文：，继续顺着知识主线往下看我们的主干知识；如果大家是直接看到了这篇博客，不知道这篇博客的因果关系的，可以回到原文先看一下[《左移运算符重载》](D:\C++Learning\Note\4.4 友元.md)）

我一开始想着给大家演示：如果我们不是以引用`MyInteger&`的方式返回，而是以`MyInteger`的方式返回，即运算符操作函数是这样子的：

```cpp
MyInteger operator++()	// 不以MyInteger&的方式返回，而是以MyInteger的方式返回
{
	value++;	
	return *this;
}
```

那么此时我们根据"拷贝构造函数的调用时机"的知识可以知道，此时`return *this`语句执行时，就会调用**拷贝构造函数**拷贝一份`*this`，然后回到测试函数中：

（注意这里"拷贝一份`*this`"的意思：编译器在内存在开辟另一块独立于`*this`，但与`*this`大小、布局相同的新的空间作为拷贝体的内存空间，并且会将`*this`中所有的属性（值）拷贝一份放到这个属于拷贝体中，比如此时`*this`中的`value = 1`，那么就会拷贝一个`value = 1`给这个拷贝体，也就是说这个拷贝体的`value`也是`1`，但是注意：`*this`与这个拷贝体的内存空间地址是不一样的，他们是在内存中占用的不是同一块内存空间，这就是拷贝构造函数调用时干的事：把属性都拷贝了，但是创建了一个新的空间来存储这些拷贝）

> <img src="E:\Typora\Image\image-20221201020824768.png" alt="image-20221201020824768" style="zoom:50%;" />

此时图中第68行代码的`++myInt1`就是`*this`的**拷贝体**的变量名：大家可以这样理解，这里红圈部分代码就相当于这段代码：`MyInterger ++myInt1 = MyInterger(*this)`（隐式转换下的拷贝构造函数调用，根据`*this`拷贝一份完全相同的变量/对象，然后用`++myInt1`来命名）

所以这里`++myInt1`也是一个`MyInteger`类型的变量，当它执行`cout << ++myInt1`时应该没有问题才对，因为`cout << ++myInt1`执行时是调用我们前面写的`<<`运算符操作函数：`ostream& operator<<(ostream& cout, MyInteger& myInt)`，很明显我们定义这个函数的时候第二个形参就是`MyInteger`类型，此时我们的`cout << ++myInt1`调用这个函数的时候，第二个参数传入的也的的确确就是`MyInteger`类型，但是编译器就是报错了，就如上图中第68行代码中`<<`下方的波浪线所示

其报错的说明是：

> <img src="E:\Typora\Image\image-20221201024133023.png" alt="image-20221201024133023" style="zoom:50%;" />
>
> 对于这个报错，我不诧异，我是非常诧异！！！

明明编译器报错的提示也是说识别到的`++myInt1`是一个`MyInteger`类型，那不就没问题了吗？你编译器直接拿去调用`<<`运算符操作函数不就好了嘛......

我在参考了这篇博客：[C++中“非常量引用的初始值必须是左值”的处理方法](https://blog.csdn.net/hou09tian/article/details/80565343)之后得到了启发，博客中说明了一个问题：

**当一个函数的形参是引用时**，比如我们案例中的左移运算符重载函数，函数的第二个形参是`MyInteger &myInt`，即表明我们在调用这个函数时，给第二个形参传入的参数在这个函数中会被起一个别名：`myInt`

```cpp
ostream& operator<<(ostream &cout, MyInteger &myInt)
{
	cout << "<<运算符操作函数调用" << endl;
	cout << myInt.value;
	return cout;
}
```

**则在调用该函数时，不能传递一个常量给这个形参。**原因是这样的，我们用上面提到的那篇博客中博主举的一个例子：

如果我们定义一个函数如下，函数的形参是声明为引用的

```cpp
void fun(int& x)
{
	x += 10;
}
```

当我们调用这个函数时，如果是这样的：

```cpp
fun(10)
```

这里我们先不把代码放到编译器中看会出现什么情况，我们先自己来思考会发生什么：

首先我们在调用fun时给传入了一个常量`10`作为参数，这个常量传给`fun`的形参`int& x`接收时，相当于给这个常量起了个别名叫`x`，然后在函数中，我们用这个别名来给这个常量，使得其进行`+= 10`的操作，这时就相当于是在给一个常量修改赋值，显然这是不能够被允许的，因为常量是不能修改赋值的！所以编译器肯定会报错！当然我们将以上代码实际地方放到编译器里头，看看编译器会报什么错：

> ![image-20221207010917991](E:\Typora\Image\image-20221207010917991.png)
>
> 报错：非常量引用的初始值必须为左值

这个报错的意思是说`fun`函数在调用时传给形参`int& x`必须是一个左值（至于什么是左值，什么是右值，我同样参考了[C++中“非常量引用的初始值必须是左值”的处理方法](https://blog.csdn.net/hou09tian/article/details/80565343)这篇博客。简单地说，**左值就是变量，右值是常量**），即要求传给这个非常量引用（形参）`int& x`必须是一个变量，而不是一个常量（右值），而上图所示的程序中我们就是传入了一个常量，从而导致编译器报错，即**对于表明为引用的函数形参，其函数在调用时传递的参数不能是常量。（或者说要求传入的参数是常量的可能性必须为0！）**

而且即使我们上面的例子将`fun`中赋值修改的语句`x += 10`去掉，编译器也是会报错，因为编译器不会理会你是否会对一个传入的可能是常量的参数进行修改，编译器只会认为这种可能性存在，所以它压根不给你这样做的机会，即使你已经把`x += 10`去掉了，你想以此来向编译器说明你不会利用这个引用对可能传入的常量进行赋值或修改，但编译器不会理会你此举的含义，它会直接在源头扼杀你，不允许你在调用`fun`的时候传入常量。

另外如果我们将上图所示程序中`fun`的形参加上一个`const`修饰，那么情况变成这样

> ​	<img src="E:\Typora\Image\image-20230114130728114.png" alt="image-20230114130728114" style="zoom:50%;" />
>
> 此时编译器的红色下划波浪线来到了`fun`中的`x`下方，`main`函数中`fun(10)`对函数的调用便不再报错。

解释为何`fun(10)`对函数的调用不再报错：因为加上`const`修饰之后，编译器认为你即使传入的是常量，但是在`fun`的内部因为这个`const`修饰`x`的缘故，导致在`fun`内部无法对`x`所命名的不管是常量也好变量也好，都无法进行修改，所以编译器可以放心地让你传入常量来调用`fun`（编译器再也不用担心你会在`fun`内部把一个传入的常量给赋值修改了，因为有`const`在，编译器很放心~），当然你这时传入一个常量也是没有问题的。

那么回到我们最开始的案例中（如下图），为什么这里会报错呢？

> <img src="E:\Typora\Image\image-20221201024133023.png" alt="image-20221201024133023" style="zoom:50%;" />

我们把`cout << ++myInt1`对左移运算符操作函数的调用的本质写出来：`operator<<(cout, ++myInt)`，由前面的解释我们知道`++myInt`是`++`运算符操作函数调用后返回的一个`MyInterger`变量，`++`运算符操作函数如下

```cpp
MyInteger operator++()	// 不以MyInteger&的方式返回，而是以MyInteger的方式返回
{
	value++;	
	return *this;
}
```

`++myInt`就是由`++`运算符操作函数调用结束后`return`返回的，我们这里返回的是`*this`，但是**编译器这里认为我们`return`的有可能是变量，也有可能是常量**，如果`return`的是一个常量，也即`++myInt`在`++`运算符操作函数调用结束后是一个常量，常量作为参数传递到`<<`运算符操作函数中，考虑到`MyInterger`类的`<<`运算符操作函数定义如下

```cpp
ostream& operator<<(ostream &cout, MyInteger &myInt)
{
	cout << "<<运算符操作函数调用" << endl;
	cout << myInt.value;
	return cout;
}
```

所以我们可以知道，`++myInt`对应传入的形参是一个非常量引用`MyInteger &myInt`，那么就会出现类似的问题：**对于表明为引用的函数形参，其函数在调用时传递的参数不能是常量。（或者说要求传入的参数是常量的可能性必须为0！）**，编译器认为这里的`++myInt`有可能是一个常量，所以出现了报错，当然这里编译器的报错也是不够明确，报的是“没有与这些操作数匹配的"<<"运算符”，应该报“非常量引用的初始值必须为左值”才对，当然这是知识水平有限的我给出的一个观点，不一定是正确的，或许编译器是有它的更好想法，只是我没有理解罢了。

同样的如果我们将<<运算符操作函数的形参`MyInteger &myInt`由非常量引用修改为常量引用：`const MyInteger &myInt`，如下

> ​	<img src="E:\Typora\Image\image-20230114151205178.png" alt="image-20230114151205178" style="zoom:50%;" />
>
> 注意这里修改之后，在`MyInteger`类定义中的友元说明也要进行相应的修改，保持统一
>
> ​	<img src="E:\Typora\Image\image-20230114151305052.png" alt="image-20230114151305052" style="zoom: 50%;" />
>
> 这里的`const`由于我们只是在函数中对`myInt`进行读取，所以在`myInt`没有修改需求的情况下，我们就把`const`留在这里了

经过修改过后，`test02`的中报错的红色下滑波浪线也消失了，如下

> ​	<img src="E:\Typora\Image\image-20230114152442294.png" alt="image-20230114152442294" style="zoom:50%;" />

当然上述代码还有另一种修改方式，就是将形参`MyInteger &myInt`中的引用声明去掉，让形参变成`MyInteger myInt`，此时也是没有问题的，因为这样一来不论是变量还是常量就都可以传给`myInt`，编译器也就同样在函数调用时不会报错了。

那大家肯定又有疑问了，为什么如果`++`运算符操作函数返回的是引用类型的时候，即

```cpp
MyInteger& operator++()
{
	value++;	
	return *this;
}
```

此时`<<`运算符操作函数的形参不加`const`却不报错呢？这里我给出的解释是这样的，我们通过一个很简单的案例来说明：

有代码如下

> ​	<img src="E:\Typora\Image\image-20230114153701357.png" alt="image-20230114153701357" style="zoom:67%;" />

这里当我们在外部调用`fun2()`时，调用完成后相当于在调用`fun2()`的地方执行了这么一段代码`int &fun2() = x`，即在函数调用执行完成后，`fun2()`相当于是`x`变量的一个别名，使用`fun2()`就是在使用`x`，也就是说我们这里给变量`x`起了个别名叫`fun2()`，那么如果我们将上述代码中的`return x`修改为`return 10`，编译器会出现这样的情况

> ​	<img src="E:\Typora\Image\image-20230114154114766.png" alt="image-20230114154114766" style="zoom: 67%;" />
>
> 报错：非常量引用的初始值必须为左值

报错的说明跟我们前面的案例一样，这里相信大家看过前面的内容一下就能知道是什么原因了，就是因为这里相当于是在`fun2()`执行完成后，给常量`10`起了一个别名叫`fun2()`，那么有可能我们会通过`fun2()`去修改这个常量，所以编译器报错，不允许有这样的事情发生。

换句话说，当我们**函数的返回值类型是引用**时，编译器上述的做法（报错非常量引用的初始值必须为左值）保证了**函数执行完成后返回的内容是一个变量，而不会是常量**。

既然返回的内容可以保证是一个变量，那么对于`<<`运算符操作函数`ostream& operator<<(ostream &cout, MyInteger &myInt)`的形参`MyInteger &myInt`，编译器能够明确传给这个形参的参数是一个变量，也就不会因为担心程序员在这里传入的参数可能是一个常量而报错了。



好，到这里我们就把上面这些知识科普完了，接下来我们回过头来讲：

> 为什么如果`++`运算符操作函数不采用返回引用`MyInteger&`的方式，而是直接返回`MyInteger`就会导致`++(++myInt)`操作的结果与`int`类型的变量在**执行相同操作**`++(++a)`时产生的结果存在差异呢？
>

根据我们的基础编程知识可知`++(++a)`执行完成后，`a`肯定是原来的`a`，或者说`a`和`++(++a)`内存是同一块，在执行`++`操作时，这个操作始终在`a`所在的这一块内存进行；

为什么如果`++`运算符操作函数不采用返回引用`MyInteger&`的方式，而是直接返回`MyInteger`就会导致++(++myInt)操作的结果与`int`类型的变量在执行相同操作`++(++a)`时产生的结果存在差异呢？`++`运算符操作函数，`++(++myInt)`的内存调用过程中我们知道，由于引用的存在，所以`++`操作始终都是在同一块内存中进行（也即链式编程），但如果`++`运算符操作函数的返回值类型为`MyInteger`，那内存调用过程就不是这么回事了，我们来看看

给出整体测试代码如下

```cpp
#include <iostream>
#include<string>
#include<stdlib.h>
using namespace std;

class MyInteger
{
	friend ostream& operator<<(ostream& cout, const MyInteger& myInt);

public:
	/// <summary>
	/// MyInteger类的无参构造：为了确保程序中定义MyInteger类型的变量（对象）且无赋初值的情况下，
	/// （默认）使得其属性value值为0
	/// </summary>
	MyInteger()	
	{
		cout << "无参构造调用" << endl;
		value = 0;
	}

	/// <summary>
	/// MyInteger类的有参构造：在程序中定义MyInteger类型的变量（对象）且同时赋初值的情况下，
	/// 使用该初值for_value作为其属性value的值
	/// </summary>
	/// <param name="for_value">
	/// ：MyInteger类型的变量（对象）定义的同时要赋值给value的初值
	/// </param>
	MyInteger(int for_value)	
	{
		cout << "有参构造调用" << endl;

		this->value = for_value;
	}

	MyInteger operator++()
	{
		cout << "++运算符操作函数调用" << endl;

		value++;	// 写成value = value + 1、value += 1、++value都没有问题，保证这行代码执行结束后value增加1即可
		return *this;
	}

private:
	int value;
};

ostream& operator<<(ostream &cout, const MyInteger &myInt)
{
	cout << "<<运算符操作函数调用" << endl;
	cout << myInt.value;
	return cout;
}

// 测试函数
void test02()
{
	MyInteger myInt1 = 0;
 cout << ++myInt1 << endl;	// 1
	cout << myInt1 << endl;


	MyInteger myInt2 = 0;
	//cout << myInt2++ << endl;	// 0
	//cout << myInt2 << endl;		// 1
}

int main()
{
	test02();

 system("pause");
	return 0;
}
```

对于测试函数`test02()`我们修改为如下

```cpp
// 测试函数
void test02()
{
	MyInteger myInt1 = 0;
	cout << &(++myInt1) << endl;	// 取地址
	cout << &myInt1 << endl;		// 取地址


	MyInteger myInt2 = 0;
	//cout << myInt2++ << endl;	
	//cout << myInt2 << endl;		
}
```

我们进行取地址操作，来看看两块内存空间的是否相同

但是编译器出现了一个意料之外的报错，如下

> ![image-20230114161629816](E:\Typora\Image\image-20230114161629816.png)
>
> 报错："&"要求左值

左值即变量，也就是说取地址操作要求取的必须是一个变量，由于这里`++myInt`在调用`++`运算符操作函数后，编译器认为该函数的返回值有可能是一个常量，所以报了上述错误。可以看出这样报错的原因也是跟我们前面的案例是相类似的。

取地址的这种方式不可行，我想了其他方法，但是苦于技术有限，没有想到能够直接验证的方法（如果看到这里的读者如果有更好地方法来验证`++myInt`和`myInt`的内存是否相同，欢迎评论区留言交流~），于是我采取了一种间接的方法来验证：

我把MyInteger类的拷贝构造函数自己实现出来，并且加上相应的调用提示，如下

```cpp
MyInteger(const MyInteger& myInt)
{
    cout << "拷贝构造调用" << endl;
    this->value = myInt.value;
}
```

> 注意这里由于这个拷贝构造函数是写在`MyInteger`类内部的，所以在访问私有属性`value`，即`this->value`和`myInt.value`时，不需要友元说明（也无法进行友元说明，那样做的话会报错）

最终的测试代码如下：

```cpp
#include <iostream>
#include<string>
#include<stdlib.h>
using namespace std;

class MyInteger
{
	friend ostream& operator<<(ostream& cout, const MyInteger& myInt);

public:
	/// <summary>
	/// MyInteger类的无参构造：为了确保程序中定义MyInteger类型的变量（对象）且无赋初值的情况下，
	/// （默认）使得其属性value值为0
	/// </summary>
	MyInteger()
	{
		cout << "无参构造调用" << endl;
		value = 0;
	}

	/// <summary>
	/// MyInteger类的有参构造：在程序中定义MyInteger类型的变量（对象）且同时赋初值的情况下，
	/// 使用该初值for_value作为其属性value的值
	/// </summary>
	/// <param name="for_value">
	/// ：MyInteger类型的变量（对象）定义的同时要赋值给value的初值
	/// </param>
	MyInteger(int for_value)
	{
		cout << "有参构造调用" << endl;

		this->value = for_value;
	}

	/// <summary>
	///  MyInteger类的拷贝构造。在实现默认拷贝构造功能的基础上，通过cout输出相关的函数调用提示信息
	/// </summary>
	/// <param name="myInt">
	/// ：MyInteger类型的变量（对象）定义的同时用于参考拷贝的变量（对象）
	/// </param>
	MyInteger(const MyInteger& myInt)
	{
		cout << "拷贝构造调用" << endl;
		this->value = myInt.value;
	}

	MyInteger operator++()
	{
		cout << "++运算符操作函数调用" << endl;

		value++;	// 写成value = value + 1、value += 1、++value都没有问题，保证这行代码执行结束后value增加1即可
		return *this;
	}

private:
	int value;
};

ostream& operator<<(ostream& cout, const MyInteger& myInt)
{
	cout << "<<运算符操作函数调用" << endl;
	cout << myInt.value;
	return cout;
}

// 测试函数
void test02()
{
	MyInteger myInt1 = 0;
	cout << ++myInt1 << endl;	// 取地址
	cout << myInt1 << endl;		// 取地址


	MyInteger myInt2 = 0;
	//cout << myInt2++ << endl;	
	//cout << myInt2 << endl;		
}

int main()
{
	test02();

	system("pause");
	return 0;
}
```

程序运行结果如下：

> ![image-20230114164627412](E:\Typora\Image\image-20230114164627412.png)

从中我们可以看到第70行代码在`++`运算符操作函数执行完成后执行了一次拷贝构造函数，这是由于返回值类型非引用所导致的，在函数执行完成`return`返回的时候，根据`myInt1`拷贝了一份拷贝体，所以我们可以看到DOS窗口显示了"拷贝构造调用"，并且这个`return`是回到`++myInt1`上的，所以这里的`++myInt1`就相当于是在`++`运算符操作函数执行完成后用来命名这份拷贝体的（或者说`++myInt1`就是这份拷贝体），因此当我们去深究`++myInt1`和`myInt1`的地址时，二者肯定是不一样的（一份是原体，另一份是拷贝体，占用两块内存空间）。

此时我们如果对`++myInt1`再一次进行`++`操作，即`++(++myInt1)`，那么可想而知又会产生一份拷贝体，此时的`++(++myInt1)`、`++myInt1`和`myInt1`占用三块不同内存，地址各不相同。所以这就能解释我们上面的那个问题：

> **为什么如果`++`运算符操作函数不采用引用`MyInteger&`的方式返回，而是直接返回`MyInteger`就会导致`++(++myInt)`操作的结果与`int`类型的变量在执行相同操作`++(++a)`时产生的结果存在差异呢？**

`++`运算符操作函数直接返回`MyInteger`的话会导致每一次`++`运算完成后都拷贝创建一份新的内存，而非一直使用原来的那块内存，这一点是与`int`类型的变量在执行相同操作`++(++a)`时产生的结果存在差异的，因为`int`类型的变量执行此操作时，一直都只有`a`这一块内存空间。但是尽管`++`运算符操作函数直接返回`MyInteger`的情况下会创建拷贝体，其程序执行结果与`int`类型的变量在执行相同操作`++(++a)`时产生的结果还是无异的（因为虽然是创建了拷贝体，但是每次的拷贝都是在`value`执行了`++`之后才进行的拷贝，`++`操作是实实在在地被执行过的，并且是能在创建拷贝体的过程中被一次次保留下去的，所以使得其产生的结果与`++(++a)`无异），单凭值打印是看不出来的，只有分析它们的内存我们才能看得出差异。

当然我们还可以采用另一种方式进行验证，我们写一个`test01()`测试函数

```cpp
void test01()
{
	int a = 0;
	cout << ++(++a) << endl;
	cout << a << endl;
}
```

该函数的运行结果是

> ​	<img src="E:\Typora\Image\image-20230114201204263.png" alt="image-20230114201204263" style="zoom: 50%;" />

如果是`++`运算符操作函数返回值类型为`MyInteger`的情况下，让`MyInteger`变量执行上述类似的操作，结果又如何呢？如下：

```cpp
void test03()
{
	MyInteger myInt = 0;
	cout << ++(++myInt) << endl;
	cout << myInt << endl;
}
```

该函数的运行结果是

> ​	<img src="E:\Typora\Image\image-20230114201740400.png" alt="image-20230114201740400" style="zoom:50%;" />

由此我们也可以看出`myInt`和`++(++myInt)`是不同的（占用不同内存空间），`++myInt`是对`myInt`自增后的拷贝，`value`为1，而`++(++myInt)`则是对`++myInt`自增后的拷贝，`value`为`2`；`++(++myInt)`括号外的`++`是对`++myInt`的内存空间进行，而不是`myInt`，只有括号内的`++`才是对`myInt`开展的。

**综上，`++`运算符重载函数的返回值类型为引用`MyInteger&`是为了一直对同一个变量（内存）进行递增操作，而不会产生拷贝体。**

当然当我们将`++`运算符重载函数的返回值类型修改为引用`MyInteger&`之后，上图所示代码的执行结果如下

> ​	<img src="E:\Typora\Image\image-20230114202751594.png" alt="image-20230114202751594" style="zoom: 50%;" />

此时程序便能正确地模仿我们`int`类型的`++(++a)`操作了！



> 而且这里我还想着给大家演示一下`myInt`和`++myInt`的地址是不一样的，以验证我前面所说的拷贝的过程是发生了的：
>
> > <img src="E:\Typora\Image\image-20221201025245983.png" alt="image-20221201025245983" style="zoom:50%;" />
>
> 当我运行程序时也报错：
>
> > ![image-20221201025415859](E:\Typora\Image\image-20221201025415859.png)
>
> 报错的位置在第69行，说什么："&"要求左值......对比这第68行的代码却没有报错，我产生了怀疑：到底`(++myInt1)`是不是`MyInteger`类型，人家`&myInt1`都不报错，怎么`&(++myInt1)`就报错了呢......这个地方我也不知道如何解释，既然我们写的`++`运算符操作函数返回的是`MyInteger`那就没错的，`++myInt1`就应该是`MyInteger`类型才对呀......
>
> 这个问题里我们暂时放一边，我们姑且理解认为`++myInt1`就是`MyInteger`类型，只不过可能是由于`&`不能搭配`++`这种操作之类的原因......
>
> 那么如果`++myInt1`就是我们所说的`MyInteger`类型，那为什么`cout << ++myInt1`调用`<<`运算符操作函数时没有识别出来呢？
>
> 我仔细揣摩了下图代码中的这四个位置：
>
> > ![image-20221201031233826](E:\Typora\Image\image-20221201031233826.png)
>
> 图中的4个位置的序号表示的这四个部分执行的相对的先后顺序：
>
> 红色1部分执行时会调用黄色2部分的函数，然后返回一个`MyInteger`类型的拷贝体，然后回到红色1部分，给这个拷贝体就命名为`++myInt1`，接着蓝色3部分执行，就会调用绿色4部分的函数，并将`++myInt1`传给图中绿色椭圆圈出来的形参。
>
> 这套执行逻辑下来，不能说是顺风顺水，只能说是行云流水，理论上就不应该存在上图中第53行代码所示的对`<<`运算符的报错。
>
> 我反复观看和对比上图的这4个部分，最后大胆地提出了一个比较另类的**设想：**
>
> **红色1部分调用黄色2部分之后返回的是`MyInteger`类型，而蓝色3部分执行时要调用绿色3部分的函数，并且要传入的形参是`MyInteger&`类型，就是由于传入的参数要求是`MyInteger&`类型，而实际传入的参数是`MyInteger`类型，从而编译器产生了这个报错。**
>
> 于是根据这个猜想，我将上图中修改绿色4部分的`MyInteger&`类型修改为`MyInteger`：
>
> > <img src="E:\Typora\Image\image-20221201105101046.png" alt="image-20221201105101046" style="zoom:50%;" />
>
> 没想到修改完成后，下面测试函数中对`<<`运算符的报错还真就消失了！！！（上图中红色划线部分）
>
> 这真的是非常意料之外的事情！因为我们上面提出的**设想**，**理论上**是**不应该成立**的，因为没有所谓的`MyInteger&`这种类型，`&`只是对形参而言，并不是对数据类型而言，`&`是用来说明：其所修饰的形参，将会是另一个变量的**别名**罢了。（这里认为`MyInteger&`不是一种数据类型的观点，是我当时写到这部分内容时的理解，后面我用了一种方法来验证`MyInteger&`到底算不算一种独立于`MyInteger`数据类型，这里大家就不着急反驳，可以顺着文章继续往下看。）
>
> 所以到底为啥会这样捏？我们先假设我们上面的设想是成立的，那么也就是说：编译器真的是认为`MyInteger&`和`MyInteger`是两个不同的类型，所以只能是`MyInteger`传给`MyInteger`、`MyInteger&`传给`MyInteger&`这样**类型对应**地去传参，而**不能**是`MyInteger&`传给`MyInteger`，或者`MyInteger`传给`MyInteger&`这样的**类型不对应地传参**。所以这里有4种情况：
>
> > 1. `MyInteger`传给`MyInteger`（猜想：可以实现）
>> 2. `MyInteger&`传给`MyInteger&`（猜想：可以实现）
> > 3. `MyInteger&`传给`MyInteger`（猜想：不可以实现）
>> 4. `MyInteger`传给`MyInteger&`（猜想：不可以实现）
> 
> 我们可以来逐个验证一下：
> 
> > **验证1：`MyInteger`传给`MyInteger`的情况上面的例子已经验证过了，这里不再重复。**
>
> > **验证2：`MyInteger&`传给`MyInteger&`**
>>
> > 代码如下：
>>
> > > <img src="E:\Typora\Image\image-20221201105450094.png" alt="image-20221201105450094" style="zoom:50%;" />
> > >
> > > 此时也没问题。
> 
> > **验证3：`MyInteger&`传给`MyInteger`。**
> >
> > 代码如下：
>>
> > > <img src="E:\Typora\Image\image-20221201111847479.png" alt="image-20221201111847479" style="zoom:50%;" />
> 
> > **验证4：`MyInteger`传给`MyInteger&`。**
> >
> > 代码如下：
>>
> > > <img src="E:\Typora\Image\image-20221201112247556.png" alt="image-20221201112247556" style="zoom:50%;" />
> > >
> > > 可以发现，此时的问题就是我们开始的那个问题。
> 
> 所以我们从上面的4个验证案例可以得出结论：
> 
> > 链式参数传递的情况下（在本例中，即`operator++()`函数的返回值作为`operator<<`函数的参数）：
>>
> > 1. 返回值是`MyInteger`**可以**传给形参为`MyInteger`的函数
>> 2. 返回值是`MyInteger&`**可以**传给形参为`MyInteger&`的函数
> > 3. 返回值是`MyInteger&`**可以**传给形参为`MyInteger`的函数
> > 4. 返回值是`MyInteger`**不可以**传给形参为`MyInteger&`的函数
> 
> 
> 
> 此时我更加诧异了......按照我们的猜想，第3种情况是"类型不对应"的情况不能实现，但实际上却实现了。所以**这里很矛盾**。
>
> 由于知识水平有限，目前我还没有办法解释这个问题，我在这里**姑且**先得出这么一个**结论**：
>
> > **`MyInteger`和`MyInteger&`是两种不同的数据类型。这两种数据类型在函数调用传参时，除了`MyInteger`类型不能传给`MyInteger&`类型之外，`MyInteger`类型传给`MyInteger`类型、`MyInteger&`传给`MyInteger&`类型、`MyInteger&`传给`MyInteger`类型都是可以实现的。**
>
> **验证`MyInteger&`和`MyInteger`是否是两种不同数据类型**（标题）
>
> 那么到底**`MyInteger&`和`MyInteger`算不算两种数据类型呢？**我想到了一个验证的方法：函数重载时，重载的条件之一就是函数的形参数据类型不同，那么我们可以写两个同名，且在同一个作用域下，但形参数据类型不同的函数（同名、同作用域是保证这两个另外的函数重载条件相同，而只有形参数据类型不同，即控制变量），我们在验证`MyInteger&`和`MyInteger`是否为两种数据类型之前，先来验证`int&`和`int`是否为两种数据类型，这样可以先避免因自定义数据类型本身的不足而产生的不确定因素，如下：
>
> ```cpp
>void fun1(int& a)
> {
>	cout << "形参类型为 int& 的函数调用" << endl;
> }
> 
> void fun1(int a)
> {
> 	cout << "形参类型为 int 的函数调用" << endl;
> }
> ```
> 
> 以上两个函数定义完成后，在这两个函数没有被调用的前提下，程序能够正常编译且不报任何错误。那么以上两个函数是否发生了重载呢？
> 
> 如果我们把第一个`fun1(int& a)`中的`&`去掉（这种情况下我们很明确，这两个函数发生的是函数重复定义，而非函数重载）
>
> 程序编译报错如下：
>
> > ![image-20221201145412025](E:\Typora\Image\image-20221201145412025.png)
>
> 也就是说如果存在函数重复定义，就会发生以上的报错。
>
> 而我们如果把第一个`fun1(int a)`中刚刚去掉`&`加回去，此时编译器是正常编译不报任何错的：
>
> > ![image-20221201145916689](E:\Typora\Image\image-20221201145916689.png)
>
> 说明这种情况下函数不发生重复定义，也即**`int& a`和`int a`是有区别**的。
>
> 但是这个区别，我们能否说它是数据类型的区别呢？或者换句话说：我们能否说这个区别是由于：`int&`和`int`是两种不同的数据类型所导致的呢？
>
> 这个问题验证的关键我认为在于：
>
> > 联系我们函数重载的知识：同作用域下的同名函数发生重载的条件之一就是：函数的形参类型不同
>>
> > 如果这两个`fun1`函数存在函数重载的话，很明显就是函数的形参类型不同所导致的
>>
> > 所以**只要我们能够验证这两个函数存重载**，**就能够说明`int&`和`int`是两种不同的数据类型**
> 
> 于是我打算在测试函数中尝试调用这两个函数，以验证它们是否存在重载。测试函数如下：
> 
> ```cpp
>// 测试函数
> void test01()
>{
> 	int a = 0;
> 	int& b = a;
> 
>     // 验证函数重载
> 	fun1(a);
> 	fun1(b);
> }
> ```
> 
> 但是我一把这个测试函数写在编译器里头，就发生下面的报错：
> 
> > ![image-20221201154434996](E:\Typora\Image\image-20221201154434996.png)首先这个报错里面有两个关键点，我已经用红框框出来了，接下来我们逐个分析一下：
>
> > 1. 编译器报错说"重载函数"，也就说明编译器认可我们上面写的两个fun1函数编译器认为是发生了重载。
>>
> > 但是我们能否像我们刚才所说，这样就认为int&和int是两种不同的数据类型了呢？我们紧接着看第2个报错的关键信息：
>>
> > 2. 编译器报错说"有多个重载函数"fun1"实例与参数列表匹配"：这是因为这里程序存在二义性，`fun1(a)`和`fun1(b)`这两个函数对于`void fun1(int& a)`和`void fun1(int a)`这两个函数都是可以调用的
> 
> 至此好像还说明不了什么问题......函数重载，编译器倒是认为是存在的，但是不知道为什么，我没有底气说这是由于`int&`和`int`是两种不同数据类型而导致的，因为我不确定编译器这里所认为的重载是否是真正的重载。我的解释是：编译器是看着`int&`和`int`的书写不一样，而肤浅地认为这是两种不同的数据类型，所以在报错的时候敢说这两个`fun1`函数发生了重载，但编译器在编译的时候有没有本质地去认识到这到底是不是两种数据类型，我也不知道......这篇博客写到这里的时候我是有些崩溃的，因为本人知识水平有限，没有学习过编译器，也不知道编译器的底层执行原理是怎样的，所以这个问题的的确确，我卡住了......暂时没有办法解释，如果大家看到这里能够对这个问题有所见解，希望不吝赐教......
> 
> 接着我就又对上图代码中对`fun1`的调用做了如下改进：
>
> > <img src="E:\Typora\Image\image-20221201162030325.png" alt="image-20221201162030325" style="zoom:50%;" />
>>
> > 即加上了强制类型转换。
>
> 此时可以看到，编译不报错了，并且程序运行之后调用的是`void fun1(int a)`，但我接下来像尝试去调用`void fun1(int& a)`：
> 
> > ![image-20221201162940834](E:\Typora\Image\image-20221201162940834.png)
>
> 好像是没办法的，也或者是我调用的方式有错......我没有想到什么办法能来调用`void fun1(int& a)`，所以还是出于严谨我觉得还是验证不了`void fun1(int a)`和`void fun1(int& a)`存在函数重载，除非能想到办法来使得`void fun1(int& a)`调用成功，同时`void fun1(int a)`也能调用成功，那我相信确实发生了函数重载。否则编译阶段，编译器所说的函数重载我不太敢相信，毕竟编译和运行是两个不同的过程。
>
> 所以到这里，我还是验证不了`int`和`int&`是否为两种不同的数据类型，但是基于引用的本质是一个指针常量，也就是说`int&`是一个`int`类型的指针，所以和`int`不能算是同种数据类型，所以`int`和`int&`应该是两种数据类型只不过`int&`是指针类型，而不是独立`int`和`int*`之外又一种新的数据类型。
>
> 但如果照着这个思路，`int&`是一种指针类型的话，那么我在调用函数时候传递一个int类型的地址就应该会调用到`void fun1(int& a)`？而实际我做了尝试之后，结果是这样的：
>
> > <img src="E:\Typora\Image\image-20221201164405594.png" alt="image-20221201164405594" style="zoom:50%;" />
>
> 编译器这个时候却反而说没有与参数列表匹配的函数，也就是说此时我传递的这个`int*`类型的`a`的地址，既不能调用`void fun1(int& a)`也不能调用`void fun1(int a)`。这个时候我甚至反过来要怀疑，引用的本质是一个指针常量的这个知识观点是否存在问题了.....
>
> 问题描述到这里，我基本已经逻辑不清了，不打算再继续往下深究了，因为自己水平可能的确是有限，目前遇到的问题是自己解释不了的，其中也不排除可能是编译器的原因而导致这些问题的存在，但无论如何，是因为自己对编译器底层的执行原理不了解所导致的，所以这个问题的探索我暂时就此打住，记录到这里，等以后自己知识水平提高之后再来尝试解决。
>
> 
>
> 那么回到我们深究"`MyInteger&`和`MyInteger`算不算两种数据类型"之前，我们得出过一个经过验证的结论：
>
> > 链式参数传递的情况下（在案例中，`operator++()`函数的返回值作为`operator<<`函数的参数）：
>>
> > 1. `MyInteger`**可以**传给`MyInteger`
>> 2. `MyInteger&`**可以**传给`MyInteger&`
> > 3. `MyInteger&`**可以**传给`MyInteger`
> > 4. `MyInteger`**不可以**传给`MyInteger&`
> 
> 我们记住第四种情况编译是无法通过就好，而另外三种情况都是可以的。
> 
> > 第4中情况：
>>
> > <img src="E:\Typora\Image\image-20221201112247556.png" alt="image-20221201112247556" style="zoom:50%;" />
>
> 至于为什么第4种情况`MyInteger`**不可以**传给`MyInteger&`捏？这里我再次展示一下上图中代码的相对执行顺序：
> 
> ![image-20221201031233826](E:\Typora\Image\image-20221201031233826.png)
>
> 序号即表示这四部分代码的相对执行顺序。仿照着这样的代码的执行顺序，我将`MyInteger`类型更换为`int`类型，并写了`fun2`函数来近似等效`operator++`函数，fun1函数代替`operator<<`函数：
>
> ![image-20221201183634358](E:\Typora\Image\image-20221201183634358.png)
>
> 这样，将`MyInteger`的问题转化为用基本数据类型`int`的问题，我们会更加明了其中的报错的原因。
>
> 这里我们着重注意当黄色2部分的函数`fun2`执行完成后返回的是`int`，返回后会在调用`fun2`时传给`fun1`的形参`int&`，这个过程就对应了前面`MyInteger`传给`MyInteger&`这种情况。
>
> 此时我们可以看到红色1部分的fun2下方也画了一条红色的波浪线以示报错，报错的原因是：
>
> **非常量引用的初始值必须为左值**
>
> 这个报错我是不理解的，于是我参考了这篇博客：[C++中“非常量引用的初始值必须是左值”的处理方法](https://blog.csdn.net/hou09tian/article/details/80565343)
>
> 博客中博主解释了何为左值，以及为了编译器回报如上的错误：
>
> ![image-20221201210044547](E:\Typora\Image\image-20221201210044547.png)
>
> ![image-20221201211326946](E:\Typora\Image\image-20221201211326946.png)
>
> 左值，简单理解就是变量。也就是说调用`fun1`函数时的第二个参数位置的`fun(a)`，编译器认为这不是变量，其认为`fun2(a)`有可能是一个常量，因为`fun2`函数调用结束时其`return`后跟的可完全可能是一个`int`类型的常量数值（例如`10`），尽管我们的代码中写的是`fun2(a)`返回的是一个变量`fun2_a`，但是编译器是无法察觉到这一点的，编译器认为`fun2(a)`有可能是一个常量数值，这个时候如果将这个常量传给`fun1`函数的`int& fun1_a`形参，就相当于在`fun1`中给这个常量取了个别名叫`fun1_a`，那么在函数中有可能对`fun1_a`进行修改，那时将相当于是在修改一个常量，这是不允许的（尽管我们在`fun1`中并没有对`fun1_a`做任何修改，但编译器仍然认为这种修改的行为可能会存在），所以编译器报错，要求我们在给`fun1`传递的第二个参数要是一个明确的变量。因此避免报错的措施有如下：
>
> 1. 调用`fun1`时第二个参数传入一个实实在在的变量
>2. 定义`fun1`时第二个形参用`const`修饰（这样就是在跟编译器说明，尽管我调用`fun1`函数时第二个传入的参数可能会是一个常量，但是我是`const`修饰的，在函数中不可能会修改到这个常量）
> 3. 将`fun2`的返回值类型改为`int&`
>
> 
> 
> 此时也没问题。如果成立，那么这样说的话也就是说传入参数一定要符合所谓的`MyInteger&`和`MyInteger&`对应，`MyInteger`和`MyInteger`对应，既然不能有`MyInteger`传给`MyInteger&`的形参，同样也不能有`MyInteger&`传给`MyInteger`的形参才对，但是对于后者：
>
> 。。。
>
> 
>
> cout 但它的地址应该和myInt1有所不同（这是根据我们上面括号中的解释进行一个猜测），我们实际
>
> 分运行和编译阶段？
>
> 当然这部分内容可能由于个人知识水平有限而存在差错和误解，如果大家在浏览的过程中发现有问题，希望大家相信坚持自己的思考和想法，当然更希望大家不吝赐教，留下你的观点和想法，与我和其他人一起交流学习！