# 补充知识

我们在第1点的最后提到的要**补充的小知识**，从这里开始：

（前情说明：这里我本来预料的结果应该是：当我删去函数的返回值类型`MyInteger&`中的`&`时，编译器不会报任何错误。但是没想到编译器居然报错了，开始的想法是编译既然报错了，不是自己预料中的事情，怕等下展开讲的时候讲不清楚......于是想着这部分的知识拓展要不然就不做了，以免让自己这篇已经写得自我感觉有点成就感的小博客[《左移运算符重载》](D:\C++Learning\Note\4.4 友元.md)就因为这里的这部分的内容解释不清楚而有些尴尬，从而导致整篇博客就因为这里的一点小插曲而留下一些小污点之类的......但是本着"展示事实，深究本质"的初衷，我决定还是就事论事，将实际产生的问题展示出来，然后看看能不能查明原因予以解决（就算查不明也能让大家一起来思考这个问题嘛，也说不定自己就真的查明了捏？嘿嘿......做以下这部分内容的展示之前，我的确是这么安慰自己的......所以下面的部分与其说是知识的补充，倒不如说是我对问题产生和尝试解决的记录，我会如实记录我的思考过程。如果大家对这部分内容不感兴趣可以直接跳回原文：[《左移运算符重载》](D:\C++Learning\Note\4.4 友元.md)，继续顺着知识主线往下看我们的主干知识）

我一开始想着给大家演示：如果我们不是以引用`MyInteger&`的方式返回，而是以`MyInteger`的方式返回，即运算符操作函数是这样子的：

```cpp
MyInteger operator++()	// 不以MyInteger&的方式返回，而是以MyInteger的方式返回
{
	value++;	
	return *this;
}
```

那么此时我们根据"拷贝构造函数的调用时机"的知识可以知道，此时`return *this`语句执行时，就会调用**拷贝构造函数**拷贝一份`*this`，然后回到测试函数中：

（注意这里"拷贝一份`*this`"的意思：编译器在内存在开辟另一块独立于`*this`，但与`*this`大小、布局相同的新的空间作为拷贝体的内存空间，并且会将`*this`中所有的属性（值）拷贝一份放到这个属于拷贝体中，比如此时`*this`中的`value = 1`，那么就会拷贝一个`value = 1`给这个拷贝体，也就是说这个拷贝体的`value`也是`1`，但是注意：`*this`与这个拷贝体的内存空间地址是不一样的，他们是在内存中占用的不是同一块内存空间，这就是拷贝构造函数调用时干的事：把属性都拷贝了，但是创建了一个新的空间来存储这些拷贝）

> <img src="E:\Typora\Image\image-20221201020824768.png" alt="image-20221201020824768" style="zoom:50%;" />

此时图中第68行代码的`++myInt1`就是`*this`的**拷贝体**的变量名：大家可以这样理解，这里红圈部分代码就相当于这段代码：`MyInterger ++myInt1 = MyInterger(*this)`

所以这里`++myInt1`也是一个`MyInteger`类型的变量，所以当它执行`cout << ++myInt1`时应该没有问题才对，因为`cout << ++myInt1`执行时是调用我们前面写的`<<`运算符操作函数：`ostream& operator<<(ostream& cout, MyInteger& myInt)`，很明显我们定义这个函数的时候第二个形参就是`MyInteger`类型，此时我们的`cout << ++myInt1`调用这个函数的时候，第二个参数传入的也的的确确就是`MyInteger`类型，但是编译器就是报错了，就如上图中第68行代码中`<<`下方的波浪线所示

其报错的原因是：

> <img src="E:\Typora\Image\image-20221201024133023.png" alt="image-20221201024133023" style="zoom:50%;" />
>
> 对于这个报错，我不诧异，我是贼tm诧异！！！

明明编译器报错的提示也是说识别到的`++myInt1`是一个`MyInteger`类型，那不就没问题了吗？你直接拿去调用`<<`运算符操作函数不就好了嘛......

我在参考了这篇博客：[C++中“非常量引用的初始值必须是左值”的处理方法](https://blog.csdn.net/hou09tian/article/details/80565343)之后得到了启发，博客中说明了一个问题：

**当一个函数的形参是引用时**，比如我们案例中的左移运算符重载函数，函数的第二个形参是`MyInteger &myInt`，即表明我们在调用这个函数时，给第二个形参传入的参数在这个函数中会被起一个别名：`myInt`

```cpp
ostream& operator<<(ostream &cout, MyInteger &myInt)
{
	cout << "<<运算符操作函数调用" << endl;
	cout << myInt.value;
	return cout;
}
```

**则在调用该函数时，不能传递一个常量给这个形参。**原因是这样的，我们用上面提到的那篇博客中博主举的一个例子：

如果我们定义一个函数如下，函数的形参是声明为引用的

```cpp
void fun(int& x)
{
	x += 10;
}
```

当我们调用这个函数时如果是这样的：

```cpp
fun(10)
```

这里我们先不把代码放到编译器中看会出现什么情况，我们先自己来思考会发生什么：

首先我们在调用fun时给传入了一个常量`10`作为参数，这个常量传给`fun`的形参`int& x`接收时，相当于给这个常量起了个别名叫`x`，然后在函数中，我们用这个别名来给这个常量`+= 10`，这时相当于是在给一个常量修改赋值，这显然是不能够被允许的，因为常量是不能修改赋值的，所以编译器肯定会报错！当然我们将以上代码实际地方放到编译器里头，看看编译器会报什么错：

> ![image-20221207010917991](E:\Typora\Image\image-20221207010917991.png)
>
> 报错：非常量引用的初始值必须为左值

相信大家对这个报错的陈述还是比较蒙的（本人也很蒙......），但是基本猜得出来，报错的原因就是我们上面分析的那样：**对于表明为引用函数形参，其在调用时传递的参数不能是常量。**

而且即使我们上面的例子将`fun`中赋值修改的语句`x += 10`去掉，编译器也是会报错，因为编译器不会理会你是否会对一个传入的可能是一个常量的参数进行修改，编译器只会认为这种可能性存在，所以它压根不给你这样做的机会，即使你已经把`x += 10`去掉了，以此说明你不会利用这个引用进行赋值修改，但编译器不会理会你此举的含义，它会直接在源头扼杀你，不允许你在调用`fun`的时候传入常量。



































而且这里我还想着给大家演示一下`myInt`和`++myInt`的地址是不一样的，以验证我前面所说的拷贝的过程是发生了的：

> <img src="E:\Typora\Image\image-20221201025245983.png" alt="image-20221201025245983" style="zoom:50%;" />

当我运行程序时也报错：

> ![image-20221201025415859](E:\Typora\Image\image-20221201025415859.png)

报错的位置在第69行，说什么："&"要求左值......对比这第68行的代码却没有报错，我产生了怀疑：到底`(++myInt1)`是不是`MyInteger`类型，人家`&myInt1`都不报错，怎么`&(++myInt1)`就报错了呢......这个地方我也不知道如何解释，既然我们写的`++`运算符操作函数返回的是`MyInteger`那就没错的，`++myInt1`就应该是`MyInteger`类型才对呀......

这个问题里我们暂时放一边，我们姑且理解认为`++myInt1`就是`MyInteger`类型，只不过可能是由于`&`不能搭配`++`这种操作之类的原因......

那么如果`++myInt1`就是我们所说的`MyInteger`类型，那为什么`cout << ++myInt1`调用`<<`运算符操作函数时没有识别出来呢？

我仔细揣摩了下图代码中的这四个位置：

> ![image-20221201031233826](E:\Typora\Image\image-20221201031233826.png)

图中的4个位置的序号表示的这四个部分执行的相对的先后顺序：

红色1部分执行时会调用黄色2部分的函数，然后返回一个`MyInteger`类型的拷贝体，然后回到红色1部分，给这个拷贝体就命名为`++myInt1`，接着蓝色3部分执行，就会调用绿色4部分的函数，并将`++myInt1`传给图中绿色椭圆圈出来的形参。

这套执行逻辑下来，不能说是顺风顺水，只能说是行云流水，理论上就不应该存在上图中第53行代码所示的对`<<`运算符的报错。

我反复观看和对比上图的这4个部分，最后大胆地提出了一个比较另类的**设想：**

**红色1部分调用黄色2部分之后返回的是`MyInteger`类型，而蓝色3部分执行时要调用绿色3部分的函数，并且要传入的形参是`MyInteger&`类型，就是由于传入的参数要求是`MyInteger&`类型，而实际传入的参数是`MyInteger`类型，从而编译器产生了这个报错。**

于是根据这个猜想，我将上图中修改绿色4部分的`MyInteger&`类型修改为`MyInteger`：

> <img src="E:\Typora\Image\image-20221201105101046.png" alt="image-20221201105101046" style="zoom:50%;" />

没想到修改完成后，下面测试函数中对`<<`运算符的报错还真就消失了！！！（上图中红色划线部分）

这真的是非常意料之外的事情！因为我们上面提出的**设想**，**理论上**是**不应该成立**的，因为没有所谓的`MyInteger&`这种类型，`&`只是对形参而言，并不是对数据类型而言，`&`是用来说明：其所修饰的形参，将会是另一个变量的**别名**罢了。（这里认为`MyInteger&`不是一种数据类型的观点，是我当时写到这部分内容时的理解，后面我用了一种方法来验证`MyInteger&`到底算不算一种独立于`MyInteger`数据类型，这里大家就不着急反驳，可以顺着文章继续往下看。）

所以到底为啥会这样捏？我们先假设我们上面的设想是成立的，那么也就是说：编译器真的是认为`MyInteger&`和`MyInteger`是两个不同的类型，所以只能是`MyInteger`传给`MyInteger`、`MyInteger&`传给`MyInteger&`这样**类型对应**地去传参，而**不能**是`MyInteger&`传给`MyInteger`，或者`MyInteger`传给`MyInteger&`这样的**类型不对应地传参**。所以这里有4种情况：

> 1. `MyInteger`传给`MyInteger`（猜想：可以实现）
> 2. `MyInteger&`传给`MyInteger&`（猜想：可以实现）
> 3. `MyInteger&`传给`MyInteger`（猜想：不可以实现）
> 4. `MyInteger`传给`MyInteger&`（猜想：不可以实现）

我们可以来逐个验证一下：

> **验证1：`MyInteger`传给`MyInteger`的情况上面的例子已经验证过了，这里不再重复。**

> **验证2：`MyInteger&`传给`MyInteger&`**
>
> 代码如下：
>
> > <img src="E:\Typora\Image\image-20221201105450094.png" alt="image-20221201105450094" style="zoom:50%;" />
> >
> > 此时也没问题。

> **验证3：`MyInteger&`传给`MyInteger`。**
>
> 代码如下：
>
> > <img src="E:\Typora\Image\image-20221201111847479.png" alt="image-20221201111847479" style="zoom:50%;" />

> **验证4：`MyInteger`传给`MyInteger&`。**
>
> 代码如下：
>
> > <img src="E:\Typora\Image\image-20221201112247556.png" alt="image-20221201112247556" style="zoom:50%;" />
> >
> > 可以发现，此时的问题就是我们开始的那个问题。

所以我们从上面的4个验证案例可以得出结论：

> 链式参数传递的情况下（在本例中，即`operator++()`函数的返回值作为`operator<<`函数的参数）：
>
> 1. 返回值是`MyInteger`**可以**传给形参为`MyInteger`的函数
> 2. 返回值是`MyInteger&`**可以**传给形参为`MyInteger&`的函数
> 3. 返回值是`MyInteger&`**可以**传给形参为`MyInteger`的函数
> 4. 返回值是`MyInteger`**不可以**传给形参为`MyInteger&`的函数



此时我更加诧异了......按照我们的猜想，第3种情况是"类型不对应"的情况不能实现，但实际上却实现了。所以**这里很矛盾**。

由于知识水平有限，目前我还没有办法解释这个问题，我在这里**姑且**先得出这么一个**结论**：

> **`MyInteger`和`MyInteger&`是两种不同的数据类型。这两种数据类型在函数调用传参时，除了`MyInteger`类型不能传给`MyInteger&`类型之外，`MyInteger`类型传给`MyInteger`类型、`MyInteger&`传给`MyInteger&`类型、`MyInteger&`传给`MyInteger`类型都是可以实现的。**

**验证`MyInteger&`和`MyInteger`是否是两种不同数据类型**（标题）

那么到底**`MyInteger&`和`MyInteger`算不算两种数据类型呢？**我想到了一个验证的方法：函数重载时，重载的条件之一就是函数的形参数据类型不同，那么我们可以写两个同名，且在同一个作用域下，但形参数据类型不同的函数（同名、同作用域是保证这两个另外的函数重载条件相同，而只有形参数据类型不同，即控制变量），我们在验证`MyInteger&`和`MyInteger`是否为两种数据类型之前，先来验证`int&`和`int`是否为两种数据类型，这样可以先避免因自定义数据类型本身的不足而产生的不确定因素，如下：

```cpp
void fun1(int& a)
{
	cout << "形参类型为 int& 的函数调用" << endl;
}

void fun1(int a)
{
	cout << "形参类型为 int 的函数调用" << endl;
}
```

以上两个函数定义完成后，在这两个函数没有被调用的前提下，程序能够正常编译且不报任何错误。那么以上两个函数是否发生了重载呢？

如果我们把第一个`fun1(int& a)`中的`&`去掉（这种情况下我们很明确，这两个函数发生的是函数重复定义，而非函数重载）

程序编译报错如下：

> ![image-20221201145412025](E:\Typora\Image\image-20221201145412025.png)

也就是说如果存在函数重复定义，就会发生以上的报错。

而我们如果把第一个`fun1(int a)`中刚刚去掉`&`加回去，此时编译器是正常编译不报任何错的：

> ![image-20221201145916689](E:\Typora\Image\image-20221201145916689.png)

说明这种情况下函数不发生重复定义，也即**`int& a`和`int a`是有区别**的。

但是这个区别，我们能否说它是数据类型的区别呢？或者换句话说：我们能否说这个区别是由于：`int&`和`int`是两种不同的数据类型所导致的呢？

这个问题验证的关键我认为在于：

> 联系我们函数重载的知识：同作用域下的同名函数发生重载的条件之一就是：函数的形参类型不同
>
> 如果这两个`fun1`函数存在函数重载的话，很明显就是函数的形参类型不同所导致的
>
> 所以**只要我们能够验证这两个函数存重载**，**就能够说明`int&`和`int`是两种不同的数据类型**

于是我打算在测试函数中尝试调用这两个函数，以验证它们是否存在重载。测试函数如下：

```cpp
// 测试函数
void test01()
{
	int a = 0;
	int& b = a;

    // 验证函数重载
	fun1(a);
	fun1(b);
}
```

但是我一把这个测试函数写在编译器里头，就发生下面的报错：

> ![image-20221201154434996](E:\Typora\Image\image-20221201154434996.png)首先这个报错里面有两个关键点，我已经用红框框出来了，接下来我们逐个分析一下：

> 1. 编译器报错说"重载函数"，也就说明编译器认可我们上面写的两个fun1函数编译器认为是发生了重载。
>
> 但是我们能否像我们刚才所说，这样就认为int&和int是两种不同的数据类型了呢？我们紧接着看第2个报错的关键信息：
>
> 2. 编译器报错说"有多个重载函数"fun1"实例与参数列表匹配"：这是因为这里程序存在二义性，`fun1(a)`和`fun1(b)`这两个函数对于`void fun1(int& a)`和`void fun1(int a)`这两个函数都是可以调用的

至此好像还说明不了什么问题......函数重载，编译器倒是认为是存在的，但是不知道为什么，我没有底气说这是由于`int&`和`int`是两种不同数据类型而导致的，因为我不确定编译器这里所认为的重载是否是真正的重载。我的解释是：编译器是看着`int&`和`int`的书写不一样，而肤浅地认为这是两种不同的数据类型，所以在报错的时候敢说这两个`fun1`函数发生了重载，但编译器在编译的时候有没有本质地去认识到这到底是不是两种数据类型，我也不知道......这篇博客写到这里的时候我是有些崩溃的，因为本人知识水平有限，没有学习过编译器，也不知道编译器的底层执行原理是怎样的，所以这个问题的的确确，我卡住了......暂时没有办法解释，如果大家看到这里能够对这个问题有所见解，希望不吝赐教......

接着我就又对上图代码中对`fun1`的调用做了如下改进：

> <img src="E:\Typora\Image\image-20221201162030325.png" alt="image-20221201162030325" style="zoom:50%;" />
>
> 即加上了强制类型转换。

此时可以看到，编译不报错了，并且程序运行之后调用的是`void fun1(int a)`，但我接下来像尝试去调用`void fun1(int& a)`：

> ![image-20221201162940834](E:\Typora\Image\image-20221201162940834.png)

好像是没办法的，也或者是我调用的方式有错......我没有想到什么办法能来调用`void fun1(int& a)`，所以还是出于严谨我觉得还是验证不了`void fun1(int a)`和`void fun1(int& a)`存在函数重载，除非能想到办法来使得`void fun1(int& a)`调用成功，同时`void fun1(int a)`也能调用成功，那我相信确实发生了函数重载。否则编译阶段，编译器所说的函数重载我不太敢相信，毕竟编译和运行是两个不同的过程。

所以到这里，我还是验证不了`int`和`int&`是否为两种不同的数据类型，但是基于引用的本质是一个指针常量，也就是说`int&`是一个`int`类型的指针，所以和`int`不能算是同种数据类型，所以`int`和`int&`应该是两种数据类型只不过`int&`是指针类型，而不是独立`int`和`int*`之外又一种新的数据类型。

但如果照着这个思路，`int&`是一种指针类型的话，那么我在调用函数时候传递一个int类型的地址就应该会调用到`void fun1(int& a)`？而实际我做了尝试之后，结果是这样的：

> <img src="E:\Typora\Image\image-20221201164405594.png" alt="image-20221201164405594" style="zoom:50%;" />

编译器这个时候却反而说没有与参数列表匹配的函数，也就是说此时我传递的这个`int*`类型的`a`的地址，既不能调用`void fun1(int& a)`也不能调用`void fun1(int a)`。这个时候我甚至反过来要怀疑，引用的本质是一个指针常量的这个知识观点是否存在问题了.....

问题描述到这里，我基本已经逻辑不清了，不打算再继续往下深究了，因为自己水平可能的确是有限，目前遇到的问题是自己解释不了的，其中也不排除可能是编译器的原因而导致这些问题的存在，但无论如何，是因为自己对编译器底层的执行原理不了解所导致的，所以这个问题的探索我暂时就此打住，记录到这里，等以后自己知识水平提高之后再来尝试解决。



那么回到我们深究"`MyInteger&`和`MyInteger`算不算两种数据类型"之前，我们得出过一个经过验证的结论：

> 链式参数传递的情况下（在案例中，`operator++()`函数的返回值作为`operator<<`函数的参数）：
>
> 1. `MyInteger`**可以**传给`MyInteger`
> 2. `MyInteger&`**可以**传给`MyInteger&`
> 3. `MyInteger&`**可以**传给`MyInteger`
> 4. `MyInteger`**不可以**传给`MyInteger&`

我们记住第四种情况编译是无法通过就好，而另外三种情况都是可以的。

> 第4中情况：
>
> <img src="E:\Typora\Image\image-20221201112247556.png" alt="image-20221201112247556" style="zoom:50%;" />

至于为什么第4种情况`MyInteger`**不可以**传给`MyInteger&`捏？这里我再次展示一下上图中代码的相对执行顺序：

![image-20221201031233826](E:\Typora\Image\image-20221201031233826.png)

序号即表示这四部分代码的相对执行顺序。仿照着这样的代码的执行顺序，我将`MyInteger`类型更换为`int`类型，并写了`fun2`函数来近似等效`operator++`函数，fun1函数代替`operator<<`函数：

![image-20221201183634358](E:\Typora\Image\image-20221201183634358.png)

这样，将`MyInteger`的问题转化为用基本数据类型`int`的问题，我们会更加明了其中的报错的原因。

这里我们着重注意当黄色2部分的函数`fun2`执行完成后返回的是`int`，返回后会在调用`fun2`时传给`fun1`的形参`int&`，这个过程就对应了前面`MyInteger`传给`MyInteger&`这种情况。

此时我们可以看到红色1部分的fun2下方也画了一条红色的波浪线以示报错，报错的原因是：

**非常量引用的初始值必须为左值**

这个报错我是不理解的，于是我参考了这篇博客：[C++中“非常量引用的初始值必须是左值”的处理方法](https://blog.csdn.net/hou09tian/article/details/80565343)

博客中博主解释了何为左值，以及为了编译器回报如上的错误：

![image-20221201210044547](E:\Typora\Image\image-20221201210044547.png)

![image-20221201211326946](E:\Typora\Image\image-20221201211326946.png)

左值，简单理解就是变量。也就是说调用`fun1`函数时的第二个参数位置的`fun(a)`，编译器认为这不是变量，其认为`fun2(a)`有可能是一个常量，因为`fun2`函数调用结束时其`return`后跟的可完全可能是一个`int`类型的常量数值（例如`10`），尽管我们的代码中写的是`fun2(a)`返回的是一个变量`fun2_a`，但是编译器是无法察觉到这一点的，编译器认为`fun2(a)`有可能是一个常量数值，这个时候如果将这个常量传给`fun1`函数的`int& fun1_a`形参，就相当于在`fun1`中给这个常量取了个别名叫`fun1_a`，那么在函数中有可能对`fun1_a`进行修改，那时将相当于是在修改一个常量，这是不允许的（尽管我们在`fun1`中并没有对`fun1_a`做任何修改，但编译器仍然认为这种修改的行为可能会存在），所以编译器报错，要求我们在给`fun1`传递的第二个参数要是一个明确的变量。因此避免报错的措施有如下：

1. 调用`fun1`时第二个参数传入一个实实在在的变量
2. 定义`fun1`时第二个形参用`const`修饰（这样就是在跟编译器说明，尽管我调用`fun1`函数时第二个传入的参数可能会是一个常量，但是我是`const`修饰的，在函数中不可能会修改到这个常量）
3. 将`fun2`的返回值类型改为`int&`



此时也没问题。如果成立，那么这样说的话也就是说传入参数一定要符合所谓的`MyInteger&`和`MyInteger&`对应，`MyInteger`和`MyInteger`对应，既然不能有`MyInteger`传给`MyInteger&`的形参，同样也不能有`MyInteger&`传给`MyInteger`的形参才对，但是对于后者：

。。。



cout 但它的地址应该和myInt1有所不同（这是根据我们上面括号中的解释进行一个猜测），我们实际

分运行和编译阶段？

当然这部分内容可能由于个人知识水平有限而存在差错和误解，如果大家在浏览的过程中发现有问题，希望大家相信坚持自己的思考和想法，当然更希望大家不吝赐教，留下你的观点和想法，与我和其他人一起交流学习！