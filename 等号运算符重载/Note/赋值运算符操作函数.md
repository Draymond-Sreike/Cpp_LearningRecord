赋值运算符操作函数未写：

![image-20230122153117779](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230122153117779.png)

赋值运算符操作函数已写：

![image-20230122153154391](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230122153154391.png)

可以说明拷构函数与等号运算符操作函数不会发生歧义调用

另外

> ![image-20230122153222538](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230122153222538.png)
>
> 这样不会调用赋值运算符操作函数

但是下面这种方式就会！

![image-20230122153431295](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230122153431295.png)

下面这种还会再调一个有参构造，是因为`p3 = 10`的本质是`p3 = Person(10)`，其中`Person(10)`会调用有参构造

![image-20230122153546318](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230122153546318.png)

以下说明p3并没有去命名另一块内存空间，始终命名的是其最开始创建时的那块空间。只是p3 = 10调用了赋值运算符操作函数，做了一次两个对象之间的属性赋值而已

![image-20230122153929568](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230122153929568.png)

以下两个案例说明在`Person p4 = p3`和`Person p5 = 10`两行代码中，赋值号的的左边`Person p`不会调用无参构造（只有仅仅只有`Person p`一行代码的时候，那样是会调用无参构造的！），但是这样写会导致其根据赋值号右边的值调用对应的构造函数，如拷贝构造、有参构造。

![image-20230122155521675](D:\C++Learning\Cpp_LearningRecord\运算符重载\Note\image-20230122155521675.png)

![image-20230122155654224](D:\C++Learning\Cpp_LearningRecord\运算符重载\Note\image-20230122155654224.png)





如果仅在值的层面，浅拷贝是没问题的，但若上升到指针/地址级别，那就不行了，因为要考虑析构函数可能存在内存重复释放的问题。