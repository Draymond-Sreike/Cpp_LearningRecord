# 头文件包含及主程序框架

```cpp
#include<iostream>
using namespace std;
#include<string.h>

int main()
{
	
    
	system("pause");
	return 0;
}
```



## 4.4 友元

- 生活中你的家有客厅（Public），有你的卧室（Private）

​		客厅，所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去

​		但是呢，你也可以允许你的好闺蜜好基友进去



- 在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术

- 友元的目的就是让一个函数或者类访问另一个类中私有成员
- 友元的关键字为：`friend`

- 友元的三种实现
    1. 全局函数做友元
    2. 类做友元
    3. 成员函数做友元



### 4.4.1**全局函数做友元**

```c++
#include<iostream>
using namespace std;
#include<string.h>

//建筑物类
class Building
{
public:
    Building()	// 无参构造
    {
        m_SittingRoom = "客厅";
        m_BedRoom = "卧室";
    }

public:
    string m_SittingRoom;

private:
    string m_BedRoom;
};

void goodGay(Building* building) // 全局函数
{
    cout << "好基友的全局函数 正在访问：" << building->m_SittingRoom << endl;

    //cout << "好基友的全局函数 正在访问：" << building->m_BedRoom << endl;	// 报错，无法访问私有属性m_BedRoom
}

void test01()
{
    Building building;	// 调用无参构造
    goodGay(&building);
}

int main()
{
    test01();
    system("pause");
}
```

**要使得全局函数void goodGay(Building* building)可以访问私有属性，需要将该函数的函数头void goodGay(Building* building)放入Building类中去声明，如下代码**

```c++
#include<iostream>
using namespace std;
#include<string.h>

class Building
{
    // 告诉编译器 goodGay(Building* building)全局函数是Building类的好朋友，可以访问类中的私有内容
    friend void goodGay(Building* building);   
    
public:
    Building()	// 无参构造
    {
        m_SittingRoom = "客厅";
        m_BedRoom = "卧室";
    }

public:
    string m_SittingRoom;

private:
    string m_BedRoom;
};

void goodGay(Building* building)
{
    cout << "好基友的全局函数 正在访问：" << building->m_SittingRoom << endl;

    // 此时下面的代码不再报错，可以访问私有属性m_BedRoom，因为这个函数是友元
    cout << "好基友的全局函数 正在访问：" << building->m_BedRoom << endl;
}

void test01()
{
    Building building;
    goodGay(&building);
}

int main()
{
    test01();
    system("pause");
}
```

- 友元全局函数在类中声明的位置不限

    

- **tips1：要用一个类，但是这个类还没有实现时，为了防止编译器报错，可以这样操作**

```c++
class Building;	// 类声明，相当于函数头声明，类中的实现可以放在后面
class GoodGay
{
public:
    Building* building;
};
```

- 即GoodGay类中要用到Building类，但是Building类的具体实现还不知道，又为了防止写Building类时编译器报错，所以可以先`class Building;`说明这个类的存在
- 具体Building类的实现**不可以**说**直接放在后面以上代码的后面**，而一定**要放在上面代码中`class Building`的后面**，还要**注意去掉**上面代码中`class Building;`**后面的分号";"**

```c++
{//将这部分代码放在上面一块代码中class Building的下面
public:
    Building();	// 无参构造

public:
    string m_SittingRoom;

private:
    string m_BedRoom;
};
```



- **tips2：类中的函数可以在类外来实现**

```C++
class Building
{
public:
    Building(); // 无参构造

public:
    string m_SittingRoom;

private:
    string m_BedRoom;
};

Building::Building()	// 类外实现Building类中的无参构造函数
{
    m_SittingRoom = "客厅";
    m_BedRoom = "卧室";
}
```



### 4.4.2**类做友元**

```c++
#include<iostream>
using namespace std;
#include<string.h>

class Building // 类声明，相当于函数头声明，类中的实现可以放在后面
{
public:
    Building();	// 无参构造

public:
    string m_SittingRoom;

private:
    string m_BedRoom;
};

class GoodGay
{
public:
    GoodGay()  // 无参构造 
    {
        // 创建建筑物对象（在堆区），让下面(GoodGay())中的Building* building去指向这个new出来的对象
        building = new Building;    //返回一个Building类型的指针，该指针指向堆区new出来的空间
    }

    void visit()   // 参观函数 访问Building中的属性
    {
        cout << "好基友正在访问：" << building->m_SittingRoom << endl;

       // cout << "好基友正在访问：" << building->m_BedRoom << endl; //报错，无法访问私有属性
    }

    Building* building; // 这个building与无参构造中的building是同一个，用于指向一个Building类对象
};



//类外实现类中的成员函数
Building::Building()
{
    m_SittingRoom = "客厅";
    m_BedRoom = "卧室";
}

void test01()
{
    GoodGay gg;
    gg.visit();
}

int main()
{
    test01();

    system("pause");
}
```

- **以上代码的执行顺序是：**

    - 先调用`GoodGay`类的构造函数创建一个`GoodGay`类对象`gg`

        - 进入该类的构造函数，在堆区创建一个`Building`对象，并用`gg`的属性`building`指向这个在堆区开辟出来的内存空间，该过程会调用`Building`的构造函数
            - `Building`构造函数将`Building`对象中的属性`m_SittingRoom`和`m_BedRoom`赋初值

    - 调用`gg.visit()`函数

        - 访问`gg`的属性`building`所指向的堆区内存空间（`Building`类对象）

            

- **可以看到`GoodGay`类对象`gg`的`visit()`行为要访问`Building`类对象`building`的私有属性时被拒绝了，要使得`gg`能够访问`building`的私有属性，可以如下操作**

```c++
#include<iostream>
using namespace std;
#include<string.h>

class Building
{
    // 告诉编译器GoodGay类是本类的好朋友，（使得GoodGay类的对象）可以访问本类中的私有成员
    friend class GoodGay;
public:
    Building();

public:
    string m_SittingRoom;

private:
    string m_BedRoom;
};

class GoodGay
{
public:
    GoodGay()
    {
        building = new Building;
    }

    void visit()
    {
        cout << "好基友正在访问：" << building->m_SittingRoom << endl;

        // 声明GoodGay类为Building类的友元后，GoodGay类对象gg即可访问Building类对象building的私有属性
        cout << "好基友正在访问：" << building->m_BedRoom << endl;  
    }

    Building* building;
};



//类外实现类中的成员函数
Building::Building()
{
    m_SittingRoom = "客厅";
    m_BedRoom = "卧室";
}

void test01()
{
    GoodGay gg;
    gg.visit();
}

int main()
{
    test01();

    system("pause");
}
```

- **注意：以上代码中GoodGay类的构造函数GoodGay()的创建Building对象building的过程：**

```c++
GoodGay()
{
	building = new Building;
}
```

**如果换成：**

```C++
GoodGay()
{
	Building building;
}
```

**此时会发生异常：**

> **引发了异常: 读取访问权限冲突。**
> **this 是 nullptr。**

**具体原因：`GoodGay`中变量`building`是`Building`类指针，如果采用`Building building`创建出来的`building`是一个变量，而非一个地址，与指针类型不兼容**



### 4.4.3 成员函数做友元

```C++
#include<iostream>
#include<string>

using namespace std;

class Building;	

class GoodGay
{
public:
	GoodGay();

	void visit01();	// 目的：使得该成员函数能够访问Building中的私有内容
	void visit02();	// 目的：该成员函数无法访问Building中的私有内容 

public:
	Building* building;
};

class Building
{
	friend void GoodGay::visit01();	// 成员函数做友元
public:
	Building();

public:
	string sittingRoom;

private:
	string bedRoom;

};
Building::Building()	// 类外实现类内函数
{
	sittingRoom = "客厅";
	bedRoom = "卧室";
}

/**********************************GoodGay类中不符合不完全类型要求的操作************************************/
GoodGay::GoodGay()
{
	building = new Building;
}
void GoodGay::visit01()
{
	cout << "GoodGay类成员函数visit01正在访问Building类对象building的：" << building->sittingRoom << endl;

	cout << "GoodGay类成员函数visit01正在访问Building类对象building的：" << building->bedRoom << endl;
}
void GoodGay::visit02()
{
	cout << "GoodGay类成员函数visit02正在访问Building类对象building的：" << building->sittingRoom << endl;

	// 报错，无法访问Building类对象building的私有属性bedRoom
	//cout << "GoodGay类成员函数visit02正在访问Building类对象building的：" << building->bedRoom << endl;
}
/******************************************************************************************************/


int main()
{
	GoodGay gg;
	gg.visit01();
	gg.visit02();

	system("pause");
}
```

- 以上代码的有关问题见：关于“ ‘xxx’: 不是类或命名空间名称” 问题的解决过程.md



# 4.5 运算符重载

对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型



## 4.5.1 加号运算符重载

作用：实现两个**自定义类型**（如`Person p1` 和 `Person p2`）相加的运算



对于内置的数据类型，编译器知道如何进行运算，如下：

```cpp
int a = 10;
int b = 10;
int c = a + b;
```

但是对于以下运算，编译器不知道如何对自定义数据类型进行相加：

```Cpp
class Person
{
public:
    int m_A;
    int m_B;
};


void test01()
{
    Person p1;
    p1.m_A = 10;
    p1.m_B = 10;

    Person p2;
    p2.m_A = 10;
    p2.m_B = 10;

    // 想创建第三个人，让第三个人的m_A和m_B属性等于p1和p2的m_A和m_B的和
    Person p3 = p1 + p2;	// 编译器此时不知道要完成我们程序员想要实现的这种操作，会报错：
    						// 		没有与这些操作数匹配的"+"运算符，操作数类型为：Person + Person
}
```

（先抛开加号运算符重载的知识）我们可以自己定义一个**成员函数**（即需要通过`p1`、`p2`这些对象来调用的函数）来实现我们想要的相加功能：

```cpp
// 在Person类内定义一个成员函数，实现我们想要的相加功能
Person PersonAddPerson(Person &p)
{
    Person tmp;
    tmp.m_A = this->m_A + p.m_A;
    tmp.m_B = this->m_B + p.m_B;
    return tmp;	// 调用拷贝构造函数，创建一个拷贝体作为返回值
}
```

这样我们可以实现相加功能：

```Cpp
Person p3 = p1.PersonAddPerson(p2);
```

但是每个程序员不一定都起名`PersonAddPerson()`，这样函数名就会因人而异，于是编译器就说：“不如我来起个名，大家都统一用我的，并且我能**承诺**提供一个简易的"+"就让你们能调用这个函数！这个通用的名称就叫`operator+`，也就是说我们上面定义的成员函数统一改成：

```Cpp
Person operator+(Person &p)
{
    Person tmp;
    tmp.m_A = this->m_A + p.m_A;
    tmp.m_B = this->m_B + p.m_B;
    return tmp;	
}
```

这个时候如果我们要来调用这个函数，正常的调用方式就是这样的：

```Cpp
Person p3 = p1.operator+(p2);	// 本质的调用方式
```

考虑到编译器的**承诺**，我们可以简化上面的调用方式为：

```cpp
Person p3 = p1 + p2;			// 简化的调用方式
```

也就是说当我们用了编译器提供的函数名：`operator+`之后，我们就可以实现上述的简化的函数调用方式，此时我们再来实现我们开始时想要实现的运算，首先我们通过成员函数来实现：

### 4.5.1.1 成员函数实现加号运算符重载

```Cpp
class Person
{
public:
    int m_A;
    int m_B;

    Person operator+(Person& p)	// 成员函数实现运算符重载
    {
        Person tmp;
        tmp.m_A = this->m_A + p.m_A;
        tmp.m_B = this->m_B + p.m_B;
        return tmp;
    }
};

void test01()
{
    Person p1;
    p1.m_A = 10;
    p1.m_B = 10;

    Person p2;
    p2.m_A = 10;
    p2.m_B = 10;

/*****************************************开始时我们想要实现的运算*****************************************/
    // 想创建第三个人，让第三个人的m_A和m_B属性等于p1和p2的m_A和m_B的和
    Person p3 = p1 + p2;	// 编译器此时就不会报错了 /******************************************************************************************************/
    cout << p3.m_A << p3.m_B << endl;	// 2020，预期的输出✔
    
    //Person p4 = p1.operator+(p2);		// 这行可以直接使用，它是第28行代码的本质调用函数，该行代码的简化调用就是
    									// 第28行代码
}
```

此时编译器就不会报错了！以上即**成员函数**实现"+"运算符重载

### 4.5.2.2 全局函数实现加号运算符重载

那么我们还可以通过**全局函数**来实现运算符重载：

```Cpp
// 在Person类外定义应该全局函数，实现我们想要的相加功能
Person operator+(Person &p1, Person &p2)
{
    Person tmp;
    tmp.m_A = p1.m_A + p2.m_A;
    tmp.m_B = p1.m_B + p2.m_B;
    return tmp;
}
```

这个时候如果我们要来调用这个函数，正常的调用方式就是这样的：

```Cpp
Person p3 = operator+(p1, p2);	// 本质的调用方式
```

我们可以同样简化上面的调用方式为：

```cpp
Person p3 = p1 + p2;			// 简化的调用方式
```

此时我们也同样可以完成我们**开始时想要实现的运算**

```Cpp
class Person
{
public:
    int m_A;
    int m_B;
};

Person operator+(Person &p1, Person &p2)	// 全局函数实现运算符重载
{
    Person tmp;
    tmp.m_A = p1.m_A + p2.m_A;
    tmp.m_B = p1.m_B + p2.m_B;
    return tmp;
}

void test01()
{
    Person p1;
    p1.m_A = 10;
    p1.m_B = 10;

    Person p2;
    p2.m_A = 10;
    p2.m_B = 10;

    //Person p3 = operator+(p1, p2);
/*****************************************开始时我们想要实现的运算*****************************************/
    // 想创建第三个人，让第三个人的m_A和m_B属性等于p1和p2的m_A和m_B的和
    Person p3 = p1 + p2;	// 编译器此时就不会报错了 
/******************************************************************************************************/
    cout << p3.m_A << p3.m_B << endl;	// 2020，预期的输出✔
    
    //Person p3 = operator+(p1, p2);	// 这行可以直接使用，它是第29行代码的本质调用函数,该行代码的简化调用就是
    									// 第29行代码
}
```

以上即完成了**全局函数**实现"+"运算符重载！



### 4.5.1.3 成员函数和全局函数的调用小区别

我们还可以注意成员函数和全局函数的调用区别：

- 成员函数：

```cpp
// 在Person类内定义一个成员函数，实现我们想要的相加功能
Person PersonAddPerson(Person &p)
{
    Person tmp;
    tmp.m_A = this->m_A + p.m_A;
    tmp.m_B = this->m_B + p.m_B;
    return tmp;	// 调用拷贝构造函数，创建一个拷贝体作为返回值
}
```

- 全局函数：

```Cpp
// 在Person类外定义应该全局函数，实现我们想要的相加功能
Person operator+(Person &p1, Person &p2)
{
    Person tmp;
    tmp.m_A = p1.m_A + p2.m_A;
    tmp.m_B = p1.m_B + p2.m_B;
    return tmp;
}
```

成员函数调用时是这样的：

```Cpp
p1.operator+(p2);
```

即通过一个对象`p1`调用函数，然后传入另一个对象`p2`作为实参

而全局函数调用是这样的：

```Cpp
operator+(p1, p2);
```

即对象`p1`和对象`p2`都作为函数实参



### 4.5.1.4 运算符重载也可以发生函数重载

函数名相同，传入的参数类型不同实现重载。

目的：复用`operator+`这个函数名



例如我们如果要实现以下代码

```cpp
Person p3 = p1 + 20;	// 此时编译器会报错：
						//		没有与这些操作数匹配的"+"运算符，操作数类型为：Person + int 
```

- 此时我们若要通过**成员函数重载**来实现运算符重载，则Person类定义如下：

```cpp
class Person
{
public:
    int m_A;
    int m_B;

    Person operator+(Person& p)	// 运算符重载
    {
        Person tmp;
        tmp.m_A = this->m_A + p.m_A;
        tmp.m_B = this->m_B + p.m_B;
        return tmp;
    }

    Person operator+(int num)	// 成员函数重载实现运算符重载
    {
        Person tmp;
        tmp.m_A = this->m_A + num;
        tmp.m_B = this->m_B + num;
        return tmp;
    }
};
```

然后在`test02()`中即可完成`Person + int`的操作且不报错：

```cpp
void test02()
{
    Person p1;
    p1.m_A = 10;
    p1.m_B = 10;

    Person p2;
    p2.m_A = 10;
    p2.m_B = 10;

    Person p4 = p1 + 20;
    cout << p4.m_A << p4.m_B << endl;	// 3030，预期的输出✔
}
```

- **全局函数**重载实现运算符重载

```cpp
class Person
{
public:
    int m_A;
    int m_B;
};

Person operator+(Person &p1, Person &p2)// 运算符重载
{
    Person tmp;
    tmp.m_A = p1.m_A + p2.m_A;
    tmp.m_B = p1.m_B + p2.m_B;
    return tmp;
}

Person operator+(Person& p1, int num)	// 全局函数重载实现运算符重载
{
    Person tmp;
    tmp.m_A = p1.m_A + num;
    tmp.m_B = p1.m_B + num;
    return tmp;
}
```

同样的可以在`test02()`中完成`Person + int`的操作且不报错。



**注意：**全局函数重载实现运算符重载时，`operator+()`中的形参类型不可调换，如下：

```cpp
Person operator+(int num, Person& p1)	
{
    Person tmp;
    tmp.m_A = p1.m_A + num;
    tmp.m_B = p1.m_B + num;
    return tmp;
}
```

调换后当我在`test02()`中调用以下代码时就会报错：

```cpp
Person p4 = p1 + 20;	// 没有与这些操作数匹配的 "+" 运算符：Person + int
```

此时只有调换参数顺序才能正常执行`test02()`，因为此时编译器只认`int + Person`的''+''操作：

```cpp
Person p4 = 20 + p1;	// 调换参数顺序，int + Person
```



**另外还要注意：**

> 1. 对于内置的数据类型（如int，double这些）的表达式的运算是不可能改变的，改变的只能是我们自定义的数据类型
> 2. 不要滥用运算符重载（即不要在写`operator+()`函数时，函数内实现的却是"-"（减）操作，这种情况编译器可以编译和运行，但不符合我们的规范！！！这叫滥用）



## 4.5.2 左移运算符重载

作用：可以输出自定义数据类型



问题引出：

```Cpp
// 定义类
class Person 
{
public:
	int m_A;
	int m_B;

	Person(int a, int b)
	{
		m_A = a;
		m_B = b;
	}
};

// 测试
void test01()
{
	int a = 10;
	cout << a << endl;
    
// 上面的操作，编译器是允许的
// 现在我们想要仿照上面的功能，实现"cout << p << endl"就能输出Person对象中的属性m_A和m_B
// 但是这样编译器就会报错
    
	Person p(10, 20);
	cout << p << endl;	// 报错：没有与这些操作数匹配的 "<<" 运算符
}
```

**以上就是左移运算符无法认识`Person`类所导致了，它需要我们为`Person`类型进行左移运算符重载**



先去掉简化问题，去掉`<< endl`，即

```cpp
void test01()
{
	int a = 10;
	cout << a << endl;
    
	Person p(10, 20);
	cout << p;	// 报错：没有与这些操作数匹配的 运算符	操作数类型为:  std::ostream << Person
}
```

首先我们通过成员函数来实现左移运算符重载，以达到最终能够使用`cout << p;`的目的：

### 4.5.2.1 成员函数实现左移运算符重载(无法实现)

在`Person`类中实现：

```cpp
class Person 
{
public:
	int m_A;
	int m_B;

	Person(int a, int b)
	{
		m_A = a;
		m_B = b;
	}
    
/******************************************成员函数实现左移运算符重载***************************************/
	// 在不知道函数名返回值类型时先写着void，后续根据应用需要再来确定具体类型
    void operator<<(Person &p){}	
    // 如果是上述的实现方式，那么调用该成员函数时就是这样的情形：p1.operator<<(p2),其简化后调用方式就是：p1 << p2
    // 这样实现的效果不是我们想要的:cout << p
/******************************************************************************************************/   
};
```

改变实现方法？......：

```cpp
class Person 
{
public:
	int m_A;
	int m_B;

	Person(int a, int b)
	{
		m_A = a;
		m_B = b;
	}
    
/******************************************成员函数实现左移运算符重载***************************************/
	void operator<<(cout){}	
    // 如果是上述的实现方式，那么调用该成员函数时就是这样的情形：p1.operator<<(cout),其简化后调用方式就是：p1 << cout
    // 这样实现的效果也不是我们想要的:cout << p
/******************************************************************************************************/   
};
```

可以看到，通过成员函数来实现重载会有一个问题，就是`Person`的对象会在`<<`的左边，这是受限于成员函数的调用语法

`(Person对象).(Person成员函数)`所导致的，由此看来：

**通过成员函数来实现左移运算符重载以达到我们预期的`cout << p;`语法效果是不可行的**

于是我们采用全局函数来实现左移运算符重载：

### 4.5.2.2 全局函数实现左移运算符重载

于是我们在全局域内定义左移运算符重载的全局函数：

```cpp
// 以下语法不可直接编译，只是先用于演绎实现该全局函数的框架
void operator<<(cout, p){}
// 如果是上述的实现方式，那么调用该成员函数时就是这样的情形：cout.operator<<(p),其简化后调用方式就是：cout << p
// 这样实现的效果就跟我们的预期相符合了
```

接下来我们就是要来完善这个全局函数的形参语法格式了，也就是他们的类型，`p`的类型好说，是`Person`，那么`cout`的类型是？？？

此处需要补充一下：

#### 关于`cout`的补充知识

`cout`的类型是`ostream`（标准输出流类），`cout`是标准输出流对象

于是上述函数的函数头`void operator<<(cout, p)`中就应该写成这样：

```cpp
void operator<<(ostream cout, Person p)
```

**由于`cout`在全局中只能有一个，也就是说不能有拷贝体，如果是上面这样定义的形参类型，就会导致该函数在调用时，函数局部内产生了一份`cout`的拷贝体，所以此处我们应该给形参`cout`加上一个`&`使得其成为一个引用目的是为了防止产生一个`cout`的拷贝体，而只是给外部传入的这个全局唯一的`cout`取了个别名也叫`cout`**

至于`Person p`习惯上我们也是为了避免调用函数时产生拷贝体而影响程序的执行效率，采用引用的方式进行参数传递

于是函数头最后应该是这样子的：

```cpp
void operator<<(ostream &cout, Person &p)
```



OK，函数头搞定接下来完善这个重载函数的函数体：

```cpp
void operator<<(ostream &cout, Person &p) 
{
	cout << "m_A =" << p.m_A << " m_B = " << p.m_B;
}
```

于是整体测试代码是这样子的：

```cpp
// 定义类
class Person 
{
public:
	int m_A;
	int m_B;

	Person(int a, int b)
	{
		m_A = a;
		m_B = b;
	}
};

// 实现左移运算符重载的全局函数
void operator<<(ostream &cout, Person &p) 
{
	cout << "m_A =" << p.m_A << " m_B = " << p.m_B;
}

// 测试
void test()
{
	int a = 10;
	cout << a << endl;

	Person p(10, 20);
	cout << p;
}
```

`void test()`执行结果：

> ![image-20221125230042389](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125230042389.png)

上述部分代码实现完毕！



但是上面的案例中我们使用的只是`cout << p;`，如果我们想要实现`cout << p << endl;`可不可行呢？

于是我把上述代码中第28行`cout << p;`改成了`cout << p << endl;`，出现了下面的情况：

> ![image-20221125230721341](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125230721341.png)
>
> 下划红色波浪线报错

这是因为`<<`的左边要是`ostream`类型的对象（如`cout`），也就是说`cout << p`执行完成后要返回一个`ostream`对象（这就是我们之前学到级联），所以就是说重载函数`void operator<<(ostream &cout, Person &p)` 的返回值类型不应该是`void`，而应该是`ostream`，所以我们将重载函数修改后如下：

```cpp
ostream& operator<<(ostream &cout, Person &p)
{
	cout << "m_A =" << p.m_A << " m_B = " << p.m_B;
	return cout;	// 返回cout这个ostream对象
}
```

此时代码`cout << p << endl;`执行的过程就是：

1. `cout << p`调用重载函数，然后返回`cout`
2. 返回逻辑是：`&(cout << p) = cout`，即给（重载函数中的）`cout`起了个别名叫`cout << p`（在测试函数`test()`中）
3. 于是`cout << p`在重载函数执行完成后就相当于`cout`
4. 此时的`cout << p << endl`就是`cout << endl`于是换行功能就能正常执行了

以上也即是链式变编程的思想。



此时整体测试代码如下：

```cpp
// 定义类
class Person 
{
public:
	int m_A;
	int m_B;

	Person(int a, int b)
	{
		m_A = a;
		m_B = b;
	}
};

// 实现左移运算符重载的全局函数
ostream& operator<<(ostream &cout, Person &p)
{
	cout << "m_A =" << p.m_A << " m_B = " << p.m_B;
	return cout;
}

// 测试
void test()
{
	int a = 10;
	cout << a << endl;

	Person p(10, 20);
	cout << p << endl;	// 加上"<< end"
}
```

代码运行结果如下：

> ![image-20221125232409616](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125232409616.png)



此时当我们将29行代码去级联其他内容时也可以正常执行

```cpp
cout << p << "Hello World!" << endl;
```

执行结果如下：

> ![image-20221125232806729](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125232806729.png)



另外还有一个**小细节**，我们如果将重载函数体中的`cout`更换其他如`out`，也是没有问题的，因为`cout`在函数中至始至终只是全局域中的`cout`的一个别名，取什么名是无所谓的，在函数中使用这个变量名`out`时，实际上使用的就是全局域中的`cout`。将重载函数体中的`cout`更换其他如`out`后，代码如下：

```cpp
ostream& operator<<(ostream &out, Person &p)
{
	out << "m_A =" << p.m_A << " m_B = " << p.m_B;
	return out;
}
```

此时执行结果不变。



考虑到实际项目开发过程中，对象的属性是私有`private`的，为了使得我们这个左移运算符重载函数能够轻松访问这些私有属性（我们不使用对象的`get()`来读取这些属性），我们结合友元技术，使得该重载函数可以访问对象的私有属性。修改后整体测试代码如下：

```cpp
// 定义类
class Person 
{
	friend ostream& operator<<(ostream& out, Person& p);	// 结合友元技术让重载函数可以访问私有属性

private:
	int m_A;
	int m_B;
	
public:
	Person(int a, int b)
	{
		m_A = a;
		m_B = b;
	}
};

// 实现左移运算符重载的全局函数
ostream& operator<<(ostream &cout, Person &p)
{
	cout << "m_A =" << p.m_A << " m_B = " << p.m_B;
	return cout;
}

// 测试
void test()
{
	int a = 10;
	cout << a << endl;

	Person p(10, 20);
	cout << p << endl;
}
```















![image-20221130222452847](E:\Typora\Image\image-20221130222452847.p

##### 

​	
